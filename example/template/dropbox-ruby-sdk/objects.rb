# Generated by BabelAPI

require 'date'



module Dropbox
  module API

    # Converts a string date to a Date object
    def self.convert_date(str)
      DateTime.strptime(str, '%a, %d %b %Y %H:%M:%S +0000')
    end

    # Fields:
    # * +path+ (+String+):
    #   Path from root. Should be an empty string for root.
    # * +rev+ (+String+):
    #   Revision of target file.
    class FileTarget
      attr_accessor(
          :path,
          :rev
      )
    
      def initialize(
        path,
        rev = nil
      )
        @path = path
        @rev = rev
      end
    
      def self.from_hash(hash)
        self.new(
          hash['path'],
          !hash.include?('rev') ? nil : hash['rev'],
        )
      end
    end
    
    # Fields:
    # * +name+ (+String+):
    #   Name of file.
    class FileInfo
      attr_accessor(
          :name
      )
    
      def initialize(
        name
      )
        @name = name
      end
    
      def self.from_hash(hash)
        self.new(
          hash['name'],
        )
      end
    end
    
    # Fields:
    # * +reason+ (+String+):
    #   A code indicating the type of error.
    class SubError
      attr_accessor(
          :reason
      )
    
      def initialize(
        reason
      )
        @reason = reason
      end
    
      def self.from_hash(hash)
        self.new(
          hash['reason'],
        )
      end
    end
    

    # Fields:
    # * +upload_id+ (+String+):
    #   A unique identifier for the upload session.
    class UploadSessionStart
      attr_accessor(
          :upload_id
      )
    
      def initialize(
        upload_id
      )
        @upload_id = upload_id
      end
    
      def self.from_hash(hash)
        self.new(
          hash['upload_id'],
        )
      end
    end
    
    # Fields:
    # * +upload_id+ (+String+):
    #   Identifies the upload session to append data to.
    # * +offset+ (+UInt64+):
    #   The offset into the file of the current chunk of data being uploaded.
    #   It can also be thought of as the amount of data that has been uploaded
    #   so far. We use the offset as a sanity check.
    class UploadAppend
      attr_accessor(
          :upload_id,
          :offset
      )
    
      def initialize(
        upload_id,
        offset
      )
        @upload_id = upload_id
        @offset = offset
      end
    
      def self.from_hash(hash)
        self.new(
          hash['upload_id'],
          hash['offset'],
        )
      end
    end
    
    # Fields:
    # * +correct_offset+ (+UInt64+):
    #   
    class IncorrectOffsetError
      attr_accessor(
          :correct_offset
      )
    
      def initialize(
        correct_offset
      )
        @correct_offset = correct_offset
      end
    
      def self.from_hash(hash)
        self.new(
          hash['correct_offset'],
        )
      end
    end
    

    # Fields:
    # * +parent_rev+ (+String+):
    #   
    class UpdateParentRev
      attr_accessor(
          :parent_rev
      )
    
      def initialize(
        parent_rev
      )
        @parent_rev = parent_rev
      end
    
      def self.from_hash(hash)
        self.new(
          hash['parent_rev'],
        )
      end
    end
    

    # Fields:
    # * +path+ (+String+):
    #   Path in the user's Dropbox to save the file.
    # * +mode+ (+ConflictPolicy+):
    #   The course of action to take if a file already exists at
    #   :field:`path`.
    # * +append_to+ (+UploadAppend+):
    #   If specified, the current chunk of data should be appended to an
    #   existing upload session.
    # * +autorename+ (+Boolean+):
    #   Whether the file should be autorenamed in the event of a conflict.
    # * +client_modified_utc+ (+UInt64+):
    #   Self reported time of when this file was created or modified.
    # * +mute+ (+Boolean+):
    #   Whether the devices that the user has linked should notify them of the
    #   new or updated file.
    class UploadCommit
      attr_accessor(
          :path,
          :mode,
          :append_to,
          :autorename,
          :client_modified_utc,
          :mute
      )
    
      def initialize(
        path,
        mode,
        append_to = nil,
        autorename = false,
        client_modified_utc = None,
        mute = false
      )
        @path = path
        @mode = mode
        @append_to = append_to
        @autorename = autorename
        @client_modified_utc = client_modified_utc
        @mute = mute
      end
    
      def self.from_hash(hash)
        self.new(
          hash['path'],
          ConflictPolicy.from_hash(hash['mode']),
          hash['append_to'].nil? ? nil : UploadAppend.from_hash(hash['append_to']),
          !hash.include?('autorename') ? nil : hash['autorename'],
          hash['client_modified_utc'].nil? ? nil : hash['client_modified_utc'],
          !hash.include?('mute') ? nil : hash['mute'],
        )
      end
    end
    

    # Fields:
    # * +reason+ (+ConflictReason+):
    #   
    class ConflictError
      attr_accessor(
          :reason
      )
    
      def initialize(
        reason
      )
        @reason = reason
      end
    
      def self.from_hash(hash)
        self.new(
          ConflictReason.from_hash(hash['reason']),
        )
      end
    end
    

    # The space quota info for a user.
    #
    # Fields:
    # * +quota+ (+UInt64+):
    #   The user's total quota allocation (bytes).
    # * +private+ (+UInt64+):
    #   The user's used quota outside of shared folders (bytes).
    # * +shared+ (+UInt64+):
    #   The user's used quota in shared folders (bytes).
    # * +datastores+ (+UInt64+):
    #   The user's used quota in datastores (bytes).
    class Space
      attr_accessor(
          :quota,
          :private,
          :shared,
          :datastores
      )
    
      def initialize(
        quota,
        private,
        shared,
        datastores
      )
        @quota = quota
        @private = private
        @shared = shared
        @datastores = datastores
      end
    
      def self.from_hash(hash)
        self.new(
          hash['quota'],
          hash['private'],
          hash['shared'],
          hash['datastores'],
        )
      end
    end
    
    # Information about a team.
    #
    # Fields:
    # * +id+ (+String+):
    #   The team's unique ID.
    # * +name+ (+String+):
    #   The name of the team.
    class Team
      attr_accessor(
          :id,
          :name
      )
    
      def initialize(
        id,
        name
      )
        @id = id
        @name = name
      end
    
      def self.from_hash(hash)
        self.new(
          hash['id'],
          hash['name'],
        )
      end
    end
    
    # Contains several ways a name might be represented to make
    # internationalization more convenient.
    #
    # Fields:
    # * +given_name+ (+String+):
    #   Also known as a first name.
    # * +surname+ (+String+):
    #   Also known as a last name or family name.
    # * +familiar_name+ (+String+):
    #   Locale-dependent familiar name. Generally matches :field:`given_name`
    #   or :field:`display_name`.
    # * +display_name+ (+String+):
    #   A name that can be used directly to represent the name of a user's
    #   Dropbox account.
    class Name
      attr_accessor(
          :given_name,
          :surname,
          :familiar_name,
          :display_name
      )
    
      def initialize(
        given_name,
        surname,
        familiar_name,
        display_name
      )
        @given_name = given_name
        @surname = surname
        @familiar_name = familiar_name
        @display_name = display_name
      end
    
      def self.from_hash(hash)
        self.new(
          hash['given_name'],
          hash['surname'],
          hash['familiar_name'],
          hash['display_name'],
        )
      end
    end
    
    # Basic information about a user's account.
    #
    # Fields:
    # * +account_id+ (+String+):
    #   The user's unique Dropbox ID.
    # * +name+ (+Name+):
    #   Details of a user's name.
    class BasicAccountInfo
      attr_accessor(
          :account_id,
          :name
      )
    
      def initialize(
        account_id,
        name
      )
        @account_id = account_id
        @name = name
      end
    
      def self.from_hash(hash)
        self.new(
          hash['account_id'],
          Name.from_hash(hash['name']),
        )
      end
    end
    
    # Information about a user's account.
    #
    # Fields:
    # * +email+ (+String+):
    #   The user's e-mail address.
    # * +country+ (+String+):
    #   The user's two-letter country code, if available.
    # * +locale+ (+String+):
    #   The language setting that user specified.
    # * +referral_link+ (+String+):
    #   The user's :link:`referral link https://www.dropbox.com/referrals`.
    # * +space+ (+Space+):
    #   The user's quota.
    # * +team+ (+Team+):
    #   If this account is a member of a team.
    # * +is_paired+ (+Boolean+):
    #   Whether the user has a personal and work account. If the authorized
    #   account is personal, then :field:`team` will always be :val:`Null`,
    #   but :field:`is_paired` will indicate if a work account is linked.
    class MeInfo < BasicAccountInfo
      attr_accessor(
          :email,
          :country,
          :locale,
          :referral_link,
          :space,
          :team,
          :is_paired
      )
    
      def initialize(
        account_id,
        name,
        email,
        country,
        locale,
        referral_link,
        space,
        team,
        is_paired
      )
        @account_id = account_id
        @name = name
        @email = email
        @country = country
        @locale = locale
        @referral_link = referral_link
        @space = space
        @team = team
        @is_paired = is_paired
      end
    
      def self.from_hash(hash)
        self.new(
          hash['account_id'],
          Name.from_hash(hash['name']),
          hash['email'],
          hash['country'].nil? ? nil : hash['country'],
          hash['locale'],
          hash['referral_link'],
          Space.from_hash(hash['space']),
          hash['team'].nil? ? nil : Team.from_hash(hash['team']),
          hash['is_paired'],
        )
      end
    end
    



  end
end