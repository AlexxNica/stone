# Generated by BabelSDK

require 'date'



module Dropbox
  module API

    # Converts a string date to a Date object
    def self.convert_date(str)
      DateTime.strptime(str, '%a, %d %b %Y %H:%M:%S +0000')
    end

    # The space quota info for a user.
    #
    # Fields:
    # * +quota+ (+UInt64+):
    #   The user's total quota allocation (bytes).
    # * +normal+ (+UInt64+):
    #   The user's used quota outside of shared folders (bytes).
    # * +shared+ (+UInt64+):
    #   The user's used quota in shared folders (bytes).
    # * +datastores+ (+UInt64+):
    #   The user's used quota in datastores (bytes).
    class QuotaInfo
      attr_accessor
          :quota, 
          :normal, 
          :shared, 
          :datastores
    
      def initialize(
        quota,
        normal,
        shared,
        datastores
      )
        @quota = quota
        @normal = normal
        @shared = shared
        @datastores = datastores
      end
    
      def self.from_hash(hash)
        self.new(
          hash['quota'],
          hash['normal'],
          hash['shared'],
          hash['datastores'].nil? ? nil : hash['datastores'],
        )
      end
    end
    
    # Information about a team.
    #
    # Fields:
    # * +name+ (+String+):
    #   The name of the team.
    class Team
      attr_accessor
          :name
    
      def initialize(
        name
      )
        @name = name
      end
    
      def self.from_hash(hash)
        self.new(
          hash['name'],
        )
      end
    end
    
    # Information for a user's account.
    #
    # Fields:
    # * +referral_link+ (+String+):
    #   The user's referral link.
    # * +display_name+ (+String+):
    #   The full name of a user.
    # * +uid+ (+UInt64+):
    #   The user's unique Dropbox ID.
    # * +country+ (+String+):
    #   The user's two-letter country code, if available.
    # * +email+ (+String+):
    #   The user's e-mail address.
    # * +quota_info+ (+QuotaInfo+):
    #   The user's quota.
    # * +team+ (+Team+):
    #   If this paired account is a member of a team.
    class AccountInfo
      attr_accessor
          :referral_link, 
          :display_name, 
          :uid, 
          :country, 
          :email, 
          :quota_info, 
          :team
    
      def initialize(
        referral_link,
        display_name,
        uid,
        country,
        email,
        quota_info,
        team
      )
        @referral_link = referral_link
        @display_name = display_name
        @uid = uid
        @country = country
        @email = email
        @quota_info = quota_info
        @team = team
      end
    
      def self.from_hash(hash)
        self.new(
          hash['referral_link'],
          hash['display_name'],
          hash['uid'],
          hash['country'],
          hash['email'],
          QuotaInfo.from_hash(hash['quota_info']),
          hash['team'].nil? ? nil : Team.from_hash(hash['team']),
        )
      end
    end
    



    # Photo-specific information derived from EXIF data.
    #
    # Fields:
    # * +time_taken+ (+Timestamp+):
    #   When the photo was taken.
    # * +lat_long+ (+List+):
    #   The GPS coordinates where the photo was taken.
    class PhotoInfo
      attr_accessor
          :time_taken, 
          :lat_long
    
      def initialize(
        time_taken,
        lat_long
      )
        @time_taken = time_taken
        @lat_long = lat_long
      end
    
      def self.from_hash(hash)
        self.new(
          convert_date(hash['time_taken']),
          hash['lat_long'].nil? ? nil : hash['lat_long'],
        )
      end
    end
    
    # Video-specific information derived from EXIF data.
    #
    # Fields:
    # * +time_taken+ (+Timestamp+):
    #   When the photo was taken.
    # * +lat_long+ (+List+):
    #   The GPS coordinates where the photo was taken.
    # * +duration+ (+Float+):
    #   Length of video in milliseconds.
    class VideoInfo
      attr_accessor
          :time_taken, 
          :lat_long, 
          :duration
    
      def initialize(
        time_taken,
        lat_long,
        duration
      )
        @time_taken = time_taken
        @lat_long = lat_long
        @duration = duration
      end
    
      def self.from_hash(hash)
        self.new(
          convert_date(hash['time_taken']),
          hash['lat_long'].nil? ? nil : hash['lat_long'],
          hash['duration'].nil? ? nil : hash['duration'],
        )
      end
    end
    
    # A file or folder entry.
    #
    # Fields:
    # * +path+ (+String+):
    #   Returns the canonical path to the file or directory.
    # * +size+ (+String+):
    #   A human-readable description of the file size (translated by locale).
    # * +bytes+ (+UInt64+):
    #   The file size in bytes.
    # * +is_dir+ (+Boolean+):
    #   Whether the given entry is a folder or not.
    # * +thumb_exists+ (+Boolean+):
    #   True if the file is an image that can be converted to a thumbnail via
    #   the /thumbnails call.
    # * +icon+ (+String+):
    #   The name of the icon used to illustrate the file type in Dropbox's
    #   icon library.
    # * +root+ (+String+):
    #   The root or top-level folder depending on your access level. All paths
    #   returned are relative to this root level. Permitted values are either
    #   dropbox or app_folder.
    # * +rev+ (+String+):
    #   A unique identifier for the current revision of a file. This field is
    #   the same rev as elsewhere in the API and can be used to detect changes
    #   and avoid conflicts.
    # * +revision+ (+UInt64+):
    #   A deprecated field that semi-uniquely identifies a file. Use rev
    #   instead.
    # * +modified+ (+Timestamp+):
    #   The last time the file was modified on Dropbox, in the standard
    #   Timestamp format (null for root folder).
    # * +is_deleted+ (+Boolean+):
    #   Whether the given entry is deleted.
    # * +hash+ (+String+):
    #   A folder's hash is useful for indicating changes to the folder's
    #   contents in later calls to /metadata. This is roughly the folder
    #   equivalent to a file's rev.
    # * +client_mtime+ (+String+):
    #   For files, this is the modification time set by the desktop client
    #   when the file was added to Dropbox, in the standard date format. Since
    #   this time is not verified (the Dropbox server stores whatever the
    #   desktop client sends up), this should only be used for display
    #   purposes (such as sorting) and not, for example, to determine if a
    #   file has changed or not.
    # * +photo_info+ (+PhotoInfo+):
    #   Only returned when the include_media_info parameter is true and the
    #   file is an image.
    # * +video_info+ (+VideoInfo+):
    #   Only returned when the include_media_info parameter is true and the
    #   file is a video.
    class EntryInfo
      attr_accessor
          :path, 
          :size, 
          :bytes, 
          :is_dir, 
          :thumb_exists, 
          :icon, 
          :root, 
          :rev, 
          :revision, 
          :modified, 
          :is_deleted, 
          :hash, 
          :client_mtime, 
          :photo_info, 
          :video_info
    
      def initialize(
        path,
        size,
        bytes,
        is_dir,
        thumb_exists,
        icon,
        root,
        rev = nil,
        revision = nil,
        modified = nil,
        is_deleted = nil,
        hash = nil,
        client_mtime = nil,
        photo_info = nil,
        video_info = nil
      )
        @path = path
        @size = size
        @bytes = bytes
        @is_dir = is_dir
        @thumb_exists = thumb_exists
        @icon = icon
        @root = root
        @rev = rev
        @revision = revision
        @modified = modified
        @is_deleted = is_deleted
        @hash = hash
        @client_mtime = client_mtime
        @photo_info = photo_info
        @video_info = video_info
      end
    
      def self.from_hash(hash)
        self.new(
          hash['path'],
          hash['size'],
          hash['bytes'],
          hash['is_dir'],
          hash['thumb_exists'],
          hash['icon'],
          hash['root'],
          hash.include?('rev') ? nil : hash['rev'],
          hash.include?('revision') ? nil : hash['revision'],
          hash.include?('modified') ? nil : convert_date(hash['modified']),
          hash.include?('is_deleted') ? nil : hash['is_deleted'],
          hash.include?('hash') ? nil : hash['hash'],
          hash.include?('client_mtime') ? nil : hash['client_mtime'],
          hash['photo_info'].nil? ? nil : PhotoInfo.from_hash(hash['photo_info']),
          hash['video_info'].nil? ? nil : VideoInfo.from_hash(hash['video_info']),
        )
      end
    end
    
    # A file or folder entry.
    #
    # Fields:
    # * +contents+ (+List+):
    #   Folder contents.
    class FileOrFolderInfo < EntryInfo
      attr_accessor
          :contents
    
      def initialize(
        path,
        size,
        bytes,
        is_dir,
        thumb_exists,
        icon,
        root,
        rev = nil,
        revision = nil,
        modified = nil,
        is_deleted = nil,
        hash = nil,
        client_mtime = nil,
        photo_info = nil,
        video_info = nil,
        contents = nil
      )
        @path = path
        @size = size
        @bytes = bytes
        @is_dir = is_dir
        @thumb_exists = thumb_exists
        @icon = icon
        @root = root
        @rev = rev
        @revision = revision
        @modified = modified
        @is_deleted = is_deleted
        @hash = hash
        @client_mtime = client_mtime
        @photo_info = photo_info
        @video_info = video_info
        @contents = contents
      end
    
      def self.from_hash(hash)
        self.new(
          hash['path'],
          hash['size'],
          hash['bytes'],
          hash['is_dir'],
          hash['thumb_exists'],
          hash['icon'],
          hash['root'],
          hash.include?('rev') ? nil : hash['rev'],
          hash.include?('revision') ? nil : hash['revision'],
          hash.include?('modified') ? nil : convert_date(hash['modified']),
          hash.include?('is_deleted') ? nil : hash['is_deleted'],
          hash.include?('hash') ? nil : hash['hash'],
          hash.include?('client_mtime') ? nil : hash['client_mtime'],
          hash['photo_info'].nil? ? nil : PhotoInfo.from_hash(hash['photo_info']),
          hash['video_info'].nil? ? nil : VideoInfo.from_hash(hash['video_info']),
          hash['contents'].nil? ? nil : hash['contents'].collect { |elem| EntryInfo.from_hash(elem) },
        )
      end
    end
    



    # Fields:
    # * +reset+ (+Boolean+):
    #   If true, clear your local state before processing the delta entries.
    #   reset is always true on the initial call to /delta (i.e. when no
    #   cursor is passed in). Otherwise, it is true in rare situations, such
    #   as after server or account maintenance, or if a user deletes their app
    #   folder.
    # * +cursor+ (+String+):
    #   A string that encodes the latest information that has been returned.
    #   On the next call to /delta, pass in this value.
    # * +has_more+ (+Boolean+):
    #   If true, then there are more entries available; you can call /delta
    #   again immediately to retrieve those entries. If 'false', then wait for
    #   at least five minutes (preferably longer) before checking again.
    class DeltaResponse
      attr_accessor
          :reset, 
          :cursor, 
          :has_more
    
      def initialize(
        reset,
        cursor,
        has_more
      )
        @reset = reset
        @cursor = cursor
        @has_more = has_more
      end
    
      def self.from_hash(hash)
        self.new(
          hash['reset'],
          hash['cursor'],
          hash['has_more'],
        )
      end
    end
    
  end
end