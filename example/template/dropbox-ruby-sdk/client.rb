# Generated by BabelAPI





module Dropbox
  module API

    # Use this class to make Dropbox API calls.  You'll need to obtain an OAuth 2 access token
    # first; you can get one using either WebAuth or WebAuthNoRedirect.
    class Client

      # Args:
      # * +oauth2_access_token+: Obtained via DropboxOAuth2Flow or DropboxOAuth2FlowNoRedirect.
      # * +locale+: The user's current locale (used to localize error messages).
      def initialize(oauth2_access_token, client_identifier = '', root = 'auto', locale = nil)
        unless oauth2_access_token.is_a?(String)
          fail ArgumentError, "oauth2_access_token must be a String; got #{ oauth2_access_token.inspect }"
        end
        @session = Dropbox::API::Session.new(oauth2_access_token, client_identifier, locale)
        @root = root.to_s  # If they passed in a symbol, make it a string

        unless ['dropbox', 'app_folder', 'auto'].include?(@root)
          fail ArgumentError, 'root must be "dropbox", "app_folder", or "auto"'
        end

        # App Folder is the name of the access type, but for historical reasons
        # sandbox is the URL root component that indicates this
        if @root == 'app_folder'
          @root = 'sandbox'
        end
      end

      # Download a file in a user's Dropbox.
      #
      # Args:
      # * +path+ (+String+):
      #   Path from root. Should be an empty string for root.
      # * +rev+ (+String+):
      #   Revision of target file.
      #
      # Returns:
      #   FileInfo
      def download(path = nil, rev = nil)
        input = {
          rev: rev,
        }
        response = @session.do_(Dropbox::API::API_CONTENT_SERVER, "download/#{ format_path(path, true) }", input)
        parsed_response = Dropbox::API::HTTP.parse_response(response, true)
        metadata = parse_metadata(response)
        return parsed_response, metadata
      end
      
      # Start an upload session.
      #
      # Args:
      #
      # Returns:
      #   UploadSessionStart
      def upload_start()
        input = {
        }
        response = @session.do_(Dropbox::API::API_CONTENT_SERVER, "upload/start", input, {}, none)
        Dropbox::API::UploadSessionStart.from_hash(Dropbox::API::HTTP.parse_response(response))
      end
      
      # Start an upload session.
      #
      # Args:
      # * +upload_id+ (+String+):
      #   Identifies the upload session to append data to.
      # * +offset+ (+UInt64()+):
      #   The offset into the file of the current chunk of data being uploaded.
      #   It can also be thought of as the amount of data that has been uploaded
      #   so far. We use the offset as a sanity check.
      #
      # Returns:
      #   Empty
      def upload_append(upload_id = nil, offset = nil, none = nil)
        input = {
          upload_id: upload_id,
          offset: offset,
        }
        response = @session.do_(Dropbox::API::API_CONTENT_SERVER, "upload/append", input, {}, none)
        Dropbox::API::Empty.from_hash(Dropbox::API::HTTP.parse_response(response))
      end
      
      # Use this endpoint to either finish an ongoing upload session that was
      # begun with :route:`UploadStart` or upload a file in one shot.
      #
      # Args:
      # * +path+ (+String+):
      #   Path in the user's Dropbox to save the file.
      # * +mode+ (+Union('ConflictPolicy', [SymbolField('overwrite'), SymbolField('add'), Field('update', Struct('UpdateParentRev', [Field('parent_rev', String, False, False)]), False, False)])+):
      #   The course of action to take if a file already exists at
      #   :field:`path`.
      # * +append_to+ (+Struct('UploadAppend', [Field('upload_id', String, False, False), Field('offset', UInt64(), False, False)])+):
      #   If specified, the current chunk of data should be appended to an
      #   existing upload session.
      # * +autorename+ (+Boolean+):
      #   Whether the file should be autorenamed in the event of a conflict.
      # * +client_modified_utc+ (+UInt64()+):
      #   Self reported time of when this file was created or modified.
      # * +mute+ (+Boolean+):
      #   Whether the devices that the user has linked should notify them of the
      #   new or updated file.
      #
      # Returns:
      #   FileInfo
      def upload(path = nil, mode = nil, append_to = nil, autorename = nil, client_modified_utc = nil, mute = nil, none = nil)
        input = {
          mode: mode,
          append_to: append_to,
          autorename: autorename,
          client_modified_utc: client_modified_utc,
          mute: mute,
        }
        response = @session.do_(Dropbox::API::API_CONTENT_SERVER, "upload/#{ format_path(path, true) }", input, {}, none)
        Dropbox::API::FileInfo.from_hash(Dropbox::API::HTTP.parse_response(response))
      end
      
      # Get information about a user's account.
      #
      # Args:
      # * +account_id+ (+String+):
      #   A user's account identifier. Use :val:`"me"` to get information for
      #   the current account.
      #
      # Returns:
      #   AccountInfo
      def info(account_id = nil)
        input = {
          account_id: account_id,
        }
        response = @session.do_(Dropbox::API::API_SERVER, "info", input)
        Dropbox::API::AccountInfo.from_hash(Dropbox::API::HTTP.parse_response(response))
      end
      
      # Get information about the authorized user's account.
      #
      # Args:
      #
      # Returns:
      #   AccountInfo
      def info_me()
        input = {
        }
        response = @session.do_(Dropbox::API::API_SERVER, "info/me", input)
        Dropbox::API::AccountInfo.from_hash(Dropbox::API::HTTP.parse_response(response))
      end
      

      private

      # From the oauth spec plus "/".  Slash should not be ecsaped
      RESERVED_CHARACTERS = /[^a-zA-Z0-9\-\.\_\~\/]/  # :nodoc:

      def format_path(path, escape = true) # :nodoc:
        # replace multiple slashes with a single one
        path.gsub!(/\/+/, '/')

        # ensure the path starts with a slash
        path.gsub!(/^\/?/, '/')

        # ensure the path doesn't end with a slash
        path.gsub!(/\/?$/, '')

        escape ? URI.escape(path, RESERVED_CHARACTERS) : path
      end

      # Parses out file metadata from a raw dropbox HTTP response.
      #
      # Args:
      # * +response+: The raw, unparsed HTTPResponse from Dropbox.
      #
      # Returns:
      # * The metadata of the file as a hash.
      def parse_metadata(response) # :nodoc:
        begin
          raw_metadata = response['x-dropbox-metadata']
          metadata = JSON.parse(raw_metadata)
        rescue
          raise DropboxError.new("Dropbox Server Error: x-dropbox-metadata=#{raw_metadata}",
                       response)
        end
        return metadata
      end

    end
  end
end