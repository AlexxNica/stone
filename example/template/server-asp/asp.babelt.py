from babelapi.data_type import (
    Boolean,
    CompositeType,
    Float32,
    Float64,
    Int32,
    Int64,
    List,
    String,
    Struct,
    SymbolField,
    Timestamp,
    UInt32,
    UInt64,
    Union,
)
from babelapi.generator.generator import CodeGeneratorMonoLingual
from babelapi.lang.python import PythonTargetLanguage

base = """\
# Auto-generated by Babel (Do not modify)
from dropbox import arg_struct_parser as asp

# We use an identity function because we don't need to mutate the return value
# of the parser in any way.
def identity(x):
    return x

"""

class ASPGenerator(CodeGeneratorMonoLingual):
    """A generator for arg_struct_parser definitions."""

    lang = PythonTargetLanguage()

    def _validator_name(self, namespace, data_type):
        """Python symbol that is assigned the validator."""
        return '{}_{}_validator'.format(
            namespace.name,
            self.lang.format_variable(data_type.name),
        )

    def _create_function_args(self, *args, **kwargs):
        """Creates the list of Python function parameters including both args
        and kwargs."""
        func_args = [self.lang.format_obj(arg) for arg in args]
        func_args.extend(['{}={}'.format(k, self.lang.format_obj(v))
                          for k, v in kwargs.items()])
        return ', '.join(func_args)

    def _create_function_args_filter_out_none_kwargs(self, *args, **kwargs):
        """Just like :meth:`ASPGenerator._create_function_args` except that
        all kwargs with values set to None are filtered out."""
        return self._create_function_args(**self._filter_out_none_valued_keys(kwargs))

    def _struct_validator_declaration(self, namespace, data_type):
        return '{} = asp.Record('.format(self._validator_name(namespace, data_type))

    def _union_validator_declaration(self, namespace, data_type):
        return '{} = asp.Variant('.format(self._validator_name(namespace, data_type))

    def _resolve_asp_type(self, namespace, field):
        """Responsible for converting a field data type in Babel to the
        appropriate record field declaration in ASP."""
        if isinstance(field, SymbolField):
            return 'object()'
        else:
            is_list = isinstance(field.data_type, List)
            if is_list:
                data_type = field.data_type.data_type
            else:
                data_type = field.data_type
            if isinstance(data_type, CompositeType):
                return self._validator_name(namespace, data_type)
            elif isinstance(data_type, String):
                s = 'asp.StringB({})'.format(
                    self._create_function_args_filter_out_none_kwargs(
                        min_length=data_type.min_length,
                        max_length=data_type.max_length,
                        regex=data_type.pattern,
                    )
                )
            elif isinstance(data_type, (Int32, Int64)):
                s = 'asp.Int()'
            elif isinstance(data_type, (UInt32, UInt64)):
                s = 'asp.Nat()'
            elif isinstance(data_type, (Float32, Float64)):
                s = 'asp.Float()'
            elif isinstance(data_type, Boolean):
                s = 'asp.Boolean()'
            elif isinstance(data_type, Timestamp):
                s = 'asp.Timestamp()'
            else:
                raise Exception('Unhandled data type %r' % data_type.name)
            if is_list:
                s = 'asp.List({})'.format(s)
            if field.nullable:
                return 'asp.Nullable({})'.format(s)
            else:
                return s

    def generate(self):
        """Generates a validator module for each namespace."""
        for namespace in self.api.namespaces.values():
            filename = 'validator_{}.py'.format(namespace.name)
            with self.output_to_relative_path(filename):
                self._generate_validator_module(namespace)

    def _generate_validator_module(self, namespace):
        """Generates a Python module that contains validators for each API data
        type in the specified namespace."""
        self.emit(base)
        for data_type in namespace.linearize_data_types():
            if isinstance(data_type, Struct):
                self.emit_line(self._struct_validator_declaration(namespace, data_type))
                with self.indent():
                    for field in data_type.fields:
                        if field.doc:
                            self.emit_wrapped_lines(field.doc, prefix='# ', width=80)
                            self.emit_empty_line()
                        if field.has_default:
                            self.emit_line("('{}', {}, {}),".format(
                                field.name,
                                self._resolve_asp_type(namespace, field),
                                self.lang.format_obj(field.default))
                            )
                        else:
                            self.emit_line("('{}', {}),".format(
                                field.name,
                                self._resolve_asp_type(namespace, field))
                            )
            elif isinstance(data_type, Union):
                self.emit_line(self._union_validator_declaration(namespace, data_type))
                with self.indent():
                    for field in data_type.fields:
                        if field.doc:
                            self.emit_wrapped_lines(field.doc, prefix='# ', width=80)
                            self.emit_empty_line()
                        self.emit_line("('{}', identity, {}),".format(
                            field.name,
                            self._resolve_asp_type(namespace, field)),
                        )
            else:
                raise ValueError('Data type %r is not a union or struct',
                                 data_type.name)
            self.emit_line(')')
            self.emit_empty_line()
